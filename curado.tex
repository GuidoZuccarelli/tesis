\chapter{Curado de los Datos}
\label{chapter:curado}

Objetivo:
Corregir todos los problemas viables encontrados en el paso anterior que se pueda.

Curado Evaluación nº 1 - Vocabularios:

Estrategia:
Se optó por adicionar al review la propiedad en forma correcta con el mismo recurso destino sin eliminar la propiedad incorrecta. 
Todo se realizó con una simple consulta SPARQL

INSERT{\\
  GRAPH ?g {\\
    ?s ?p ?o .\\
  }\\
}\\
WHERE{\\
  SELECT ?g ?s (IRI(CONCAT("http://schema.org/", ?prop)) AS ?p) ?o\\
  WHERE{\\
    GRAPH ?g{\\
      ?s ?t ?o .\\
      FILTER(REGEX(str(?t), "http://schema.org/*+", "i")).\\
      BIND(REPLACE(str(?t), '^.*(#|/)', "") AS ?prop)\\
    }\\
  }\\
}\\

Resultados:
Se crearon 2498221 propiedades nuevas de forma correcta correspondientes a cada una de las propiedades incorrectas de la ontología 
schema.

Curado Evaluación nº 2 - Duplicados

Estrategia: 

Se recorrieron todos los grupos de duplicados y se procedió a realizar la siguiente operación:
Se le asignó a cada grupo un id único, al cual llamaremos groupId.
Lueog por cada grupo de duplicados se seleccionó de manera arbitraria un representante con un criterio que se describirá a continuación:
Si dentro del conjunto de documentos entre los cuales se encuentran todos los integrantes del grupo de duplicados no existe ninguno 
que contenga un recurso ya elegido anteriormente como representante, se selecciona cualquier recurso de la lista de duplicados al azar.
Caso contrario, se selecciona el primer recurso encontrado en la lista, que pertenezca al documento que ya contiene algún recurso escogido 
como representante.
Esto se realizó de esa forma, para que todos los representantes se concentren en los mismos documentos y no suceda que dados 2 
documentos idénticos con 2 reviews cada uno, no terminen con un representante cada uno. De esta forma se minimizan la cantidad de 
documentos con reviews en el dataset.
Luego de elegir un representante para el grupo de duplicados, a ese recurso se le asignó una propiedad http://local.org/representantOf y 
como objeto de la propiedad el groupId.
Y para todos los recursos restantes del grupo de duplicados, se les asignó una propiedad http://local.org/duplicatedOf con objeto 
el groupId.

Resultados:

Se asignaron 78705 propiedades duplicatedOf y 17343 representantOf

Curado Evaluación nº 3 - RDFUnit Automático:

Muchos de los problemas detectados por el framework, no otorgaban demasiada información, como por ejemplo
http://schema.org/datePublished does not have datatype: http://www.w3.org/2001/XMLSchema\#date el cual sólo especifica que le 
falta el tipo al recurso objeto, pero no necesariamente significa que esté mal, esto da un indicio de que algo puede andar mal
y será verificado en la consulta manual, en este caso por ejemplo, lo importante es que la fecha tenga el formato apropiado.
Se decidió entonces atacar los problemas más específicos:

http://schema.org/ratingValue has rdfs:domain different from: http://schema.org/Rating

Estrategia:
Primero hubo que investigar, cuáles son todos los dominios para esa propiedad que aparecen en el dataset, para ver si se pueden 
acomodar. Esto se realizó con la siguiente consulta sparql:

select distinct ?dominio (count (?s) as ?cantidad) \\
where{\\
?s <http://schema.org/ratingValue> ?value .\\
?s a ?dominio .\\
}GROUP BY ?dominio\\

Y los resultados fueron

\begin{tabular}{| l | c |}
 <http://schema.org/Rating> & 120165\\
 <http://schema.org/AggregateRating> & 54815 \\
 <http://schema.org/Review> & 5867 \\
 <http://schema.org/Product> & 331 \\
\end{tabular}

Se puede apreciar que en la mayor parte de los casos de error, se dieron porque se incluyó la propiedad ratingValue directamente en 
el Review. Ahora surge la necesidad de saber si esos casos donde el Review tiene la propiedad ratingValue, existe una propiedad reviewRating 
con su respectivo Rating.
Se relizó la consulta:
select (count (?s) as ?cantidad) \\
where{\\
?s a <http://schema.org/Review> . \\
?s <http://schema.org/ratingValue> ?value . \\
?s <http:schema.org/reviewRating> ?rating . \\
}

El resultado fue 0.

Por lo tanto ese problema se solucionó con la siguiente consulta:

DELETE { \\
GRAPH ?g{ \\
?s <http://schema.org/ratingValue> ?value . \\
} \\
} \\
INSERT{ \\
GRAPH ?g{ \\
?s <http://schema.org/reviewRating> ?rating . \\
?rating a <http://schema.org/Rating> . \\
?rating <http://schema.org/ratingValue> ?value . \\
}\\
}\\
WHERE{\\
GRAPH ?g {\\
?s a <http://schema.org/Review> .\\
?s <http://schema.org/ratingValue> ?value .\\
}\\
}\\

schema:worstRating and schema:bestRating has rdfs:domain different from: http://schema.org/Rating
Estrategia:
El proceso es igual al anterior y los dominios disintos de rating eran Review, la misma cantidad que en el anterior 5867

Resultados: 
Idem los anteriores.

http://schema.org/itemReviewed is missing proper range

Estrategia:
Esta evaluación se refiere a que existen recursos objeto de dicha propeidad, que no tienen un tipo específico. Para ver si 
puede ser resuelto, primer hubo que evaluar qué clase de recursos contienen como objeto, esas propiedades que presentaron problemas.

Resultado:
La evaluación encontró que, todos esos recursos eran URIs de un dominio web 411ca.com para ser derreferenciados. La solución podría haber sido 
descargar dichos recursos y anexarlos a la propiedad, pero lamentablemente dichos recursos no se encontraban disponibles de forma online.

Curado Evaluación nº 3 - RDFUnit Manual:

\{DateProperty} has a format different to YYYY-MM-DD:
Para todas las propiedades que indiquen una fecha, los pasos para reparar este caso son los mismos.

Cuando nos encontramos con este caso, se requiere de otra evaluación para entender cómo encarar el problema. Es una evaluación cuyo resultado
pueda responder la siguiente pregunta:

Si no tiene formato YYYY-MM-DD, ¿Qué formato tiene?

La idea en esta evaluación entonces, es encontrar qué formatos distintos contienen los datos, para poder trasladarlos al correcto.

Estrategia:

Comenzando con la siguiente consulta:

SELECT distinct ?date 
WHERE{
?review <http://local.org/id> ?id .
?review {DateProperty} ?date .
FILTER (!REGEX(str(?date), "^[0-9]{4}-[0-9]{2}-[0-9]{2}\$", "i")) .
FILTER NOT EXISTS{
?review <http://local.org/deplicateOf> ?dup.
}
}

Esta consulta retorna la fecha de todos los reviews que no estén duplicados y que además dicha fecha no tenga el formato YYYY-MM-DD

Luego observando los resultados manualmente, se prsta atención also primeros resultados y se trata de encontrar con qué patrón están formados 
para luego anotarlo y realizar la misma consulta esta vez filtrando los reusltados ocn dicho patrón. Iterando este proceso hasta que 
queden 0 resultados.

Resultados:

Se descubrieron los siguientes patrones
\\
\\
http://schema.org/datePublished
\begin{tabular}{| l | c |}
Expresión regular & Cantidad de reviews\\
^[A-z]+ [0-9]{2}, [0-9]{4}\$ & 14715 \\
^[0-9]{4}-[0-9]{2}-[0-9]{2}.+ & 17700 \\
^[0-9]{4}-[0-9]{2}-[0-9]{1} [0-9]{2}:[0-9]{2}:[0-9]{2}\$ & 7179 \\
^[0-9]{2}\\.[0-9]{2}\\.[0-9]{4}\$ & 7172\\
^[A-z]+ [0-9]{2}, [0-9]{4}.+ & 5049\\
^[A-z]{3} [0-9]{1}, [0-9]{4} & 1847\\
^[0-9]{2}\\.[0-9]{1}\\.[0-9]{4}\$ & 410\\
^[0-9]{1}\\.[0-9]{1}\\.[0-9]{4}\$ & 120\\
[0-9]{2}/[0-9]{2}/[0-9]{2} & 67\\
^[0-9]{1}\\.[0-9]{2}\\.[0-9]{4}\$ & 30
\end{tabular}

http://purl.org/dc/terms/date
\begin{tabular}{| l | c |}
Expresión regular & Cantidad de reviews\\
^[0-9]{4}-[0-9]{2}-[0-9]{2}.+ & 33833\\
^[A-z]+.[A-z]{2}.[0-9]{4}-[0-9]{2}-[0-9]{2}\$ & 33058\\
^[A-z]{3}\\n.*[0-9]{1}\\n.*[0-9]{4}\$ & 25543\\
^[A-z]{3}\\n.*[0-9]{2}\\n.*[0-9]{4}\$ & 17770\\
^[A-z]+ [0-9]{2}, [0-9]{4}\$ & 17069\\
[0-9]{2}((?!-).)[0-9]{2}((?!-).)[0-9]{4} & 11720\\
^[0-9]{2} [A-zéû]+ [0-9]{4} & 4147\\
^[0-9]{2}((?!-).)[0-9]{2}((?!-).)[0-9]{4} & 4093\\
^[0-9]{2}((?!-).)[0-9]{1}((?!-).)[0-9]{4} & 2803\\
^[A-z]{3} [0-9]{1}, [0-9]{4} & 2783\\
^[A-z]+ [0-9]{2}[a-z]{2} [0-9]{4}\\.\$ & 2058\\
^[0-9]{2} [A-z]{3} [0-9]{4} & 1730\\
^[0-9]{1}((?!-).)[0-9]{1}((?!-).)[0-9]{4}\$. & 1103\\
^[0-9]{2}-[0-9]{2}-[0-9]{4}\$ & 1024\\
^[A-z]+ [0-9]{1}[a-z]{2} [0-9]{4}\\.\$ & 746\\
^[0-9]{1}((?!-).)[0-9]{2}((?!-).)[0-9]{4}\$ & 279\\
\end{tabular}

\\
http://schema.org/publishDate
\begin{tabular}{| l | c |}
Expresión regular & Cantidad de reviews\\
[0-9]{2}/[0-9]{2}/[0-9]{2} & 2511\\
^[0-9]{2}\\.[0-9]{2}\\.[0-9]{4}\$ & 2207
\end{tabular}

\\
http://schema.org/dtreviewed
\begin{tabular}{| l | c |}
Expresión regular & Cantidad de reviews\\
^[0-9]{1}((?!-).)[0-9]{2}((?!-).)[0-9]{4}\$ & 14762\\
^[0-9]{1}((?!-).)[0-9]{1}((?!-).)[0-9]{4}\$ & 6358\\
^[0-9]{2}((?!-).)[0-9]{2}((?!-).)[0-9]{4}\$ & 4193\\
^[0-9]{2}((?!-).)[0-9]{1}((?!-).)[0-9]{4}\$ & 1590
\end{tabular}

Una vez encontrados los patrones, sólo fue cuestion de correr un algoritmo en Java dónde se contemplan todo los patrones y se 
le aplica la correción apropiada al String y se vuelve a almacenar en el review.
También en varios casos hubo que verificar dónde se encontraba el día y dónde el mes como por ejemplo para casos como éste ^[0-9]{2}\\.[0-9]{2}\\.[0-9]{4}\$ & 2207 
Manualmente se observan los resultados de ese patrón y se puede observar si los primeros 2 números son mes o día.

