\chapter{Integración de los Datos}
\label{chapter:integracion}

Como quedó explicado en la sección \ref{section:integracion}, integración comprende los procedimientos que se realizan con el objetivo de obtener una
visión más unificada del dataset.
Esto puede significar, modificar los datos y ontologías y también agregar información faltante en los ítems/reviews.
Este es el paso más importante de todo el proceso y la posibilidad de conseguir realizar una aplicación correcta que satisfaga los requerimientos
depende del éxito obtenido en el mismo.
En base a los requerimientos establecidos, se pueden pensar en distintos procedimientos que son necesarios para poder explotar los datos
correctamente:
\\
\\
Unificación de vocabularios: En el primer paso del proceso se realizó una selección de los vocabularios con los que se trabajará, 
estos vocabularios modelan el mismo dominio de información pero muchas veces de forma distinta. Explotar información modelada de 
diferentes maneras puede resultar innecesariamente engorroso, y también para quienes en un futuro quieran hacer uso del dataset (ya que
deberán consutlar la información previamente conociendo todas las ontologías de review existentes).\\
Unificación de autores: Es muy importante para lograr cumplir el objetivo de los requerimientos que si dos reviews distintos fueron 
generados por el mismo autor, esto quede explícitamente asentado, para poder realizar los algoritmos de recomendación.\\
Unificación de ítems: El paso más difícil y más importante, si un ítem está modelado dos veces de forma distinta debería saberse que 
se trata del mismo.\\
Unificación de formato de ratings: Si bien este paso sería válido también en la etapa de curación, se decidió que encajaba mejor acá.
Se trata de llevar todos los ratings a un formato único numérico. Hay sitios que establecen los ratings de distintas formas como 
por ejemplo ``4 out of 5''. En sí no es un problema sintáctico dado que no hay un rango establecido para las propiedades de rating, 
pero va a presentar problemas a la hora de utilizar la información en conjunto, ya que se requerirá tener en cuenta todos los casos 
distintos de formatos de ratings. Puede verse como un problema semántico, tomando en cuenta el ejemplo 4 out of 5, no es más que una sobrecarga de 
propiedades, ya que como valor de la propiedad rating, se especifica no sólo el valor de dicha propìedad, sino que además el valor de la 
propiedad maxRating. \\
Unificación de tipos de ítems: Esto es muy útil para darle más posibilidades a la aplicación, y es agrupar los ítems según su tipo 
(Libro, película, Hotel, Auto, etc), de manera que por ejemplo si un usuario quiere que le recomienden un libro, la aplicación sólo 
le ofresca libros. Para la ontología schema, esto puede ser más sencillo dado que los ítems ya se encuentran con su tipo identificado con 
la clase, en el caso de libro, sería cuestión de buscar ítems con la clase schema:Book. El problema es que esto puede no ocurrir siempre, 
Un libro, puede estar clasificado como schema:Product, por lo que necesitaría que también lo clasifiquen como Book.\\
\\
\\
Por razones de que la tesis ya cubrió el desarrollo suficiente, sólo se intentarán implementar los puntos 1, 3 y 4 de la integración. Ya que 
los otros dos poseén una complejidad muy alta y su implementación llevaría mucho tiempo.\\
\\
\section{Unificación de vocabularios}
\label{section:unificacion-vocabularios}

Objetivo: Conservar los reviews del dataset en una única ontología. Lo que simplificará las búsquedas, agregaciones y otras operaciones.
Además de contener datos semánticamente más parecidos. Y también facilitará la comprensión del dataset a quienes quieran hacer uso del mismo
en un futuro (ya que sólo deberán concentrarse en una sola ontología)
\\
Estrategia: Deberá como primer paso realizarse una selección de vocabulario, en la cual se escoja uno para que quede como el único en el dataset.
En este caso de estudio el vocabulario elejido es Review Ontology, ya que todas sus propiedades son suficientes para cumplir los requerimientos y 
este es mucho más simple, lo que facilitará su utilización. El vocabulario de schema poseé demasiadas propiedades que son irrelevantes para este caso de estudio. 
Además vale la pena recordar los problemas encontrados en el capítulo evaluación causados por la ontología.
Como segundo paso, buscar para cada propiedad de schema:Review utilizada en el dataset su contraparte en la ontología purl.\\
La equivalencia entre las propiedades ya fueron realizadas en el capítulo de selección de vocabularios. Pero sólo fue realizado con las propiedades 
relevantes al caso de estudio. Las siguientes propiedades (que valga la redundancia son irrelevantes al caso de estudio) fueron utilizadas dentro del dataset, y 
no se estableció su equivalente en el otro vocabulario:
http://schema.org/about y http://schema.org/keywords. 
Si bien, la falta de estas propiedades no impactará sobre la aplicación final, es conveniente no perder datos para la publicación del dataset, ya que 
a alguien podría resultarle útil. 
En la etapa de evaluación se observó que la propiedad about, se utilizó en el dataset sólo para poner contener el valor ``This is required'' en todos los casos. 
Por lo que no incluir esta propiedad en el dataset no producirá una pérdida de información.
Y la propiedad keywords puede ser reemplazada por http://purl.org/dc/terms/subject. Ya que en la documentación de dublin core, proponen la utilización de esta propiedad 
utilizando keywords.
El caso de reviewRating, que tiene como objeto un schema:Rating, no puede ser explicitamente reemplazado, ya que esa propiedad 
sólo es utilizada para desacoplar el rating del review, situación que no se da en la otra ontología. Pero las propiedades dentro del rating se encuentran todas 
con su equivalente en purl, por lo tanto no causará ningún problema.
Por último, schema:Person que es rango de la propiedad author, debería ser mapeado a foaf:Person que es rango de la propiedad reviewer. 
El problema se encuentra en lo analizado en la etapa de curado, que se observó que los nombres de los autores podía ser nomrbes completos o usernames. 
Y no existe una propiedad dentro del vocabulario de foaf:Person que sea tan genérico como para contemplar todo slos casos posibles, como sí existe en vCard.
Además de que todos los previos valores de reviewer están conformados por un vCard, como también ya se analizó en la etapa de curado.
Por estos motivos se determinó continuar utilizando vCards en lugar de recursos de tipo foaf, y dichos vCards utilizarán la propiedad
fn (que contempla todos los casos mencionados).
Finalmente el mapeo de propiedades quedó:\\
\begin{tabular}{| l | c |}
Propiedad schema & Propiedad de reemplazo\\
name & title \\
reviewBody & text \\
datePublished & dc:date \\
author & reviewer \\
reviewer & reviewer \\
ratingValue & rating\\
bestRating (reviewRating) & maxRating\\
worstRating (reviewRating)& minRating\\
url & vcard:url\\
keywords & dc:subject\\
name (author) & vcard:fn (reviewer)\\
comments & hasComment\\
author (comment) & commenter \\
text (comment) & text 
\end{tabular}

No hubo problemas con el algoritmo que realizaba el procedimiento.
\\
\\
\section{Unificación de formatos de ratings}
\label{section:unificacion-ratings}

Objetivo: Disponer de todos los ratings de los reviews, con el mismo formato. Un número sin decimales, para facilitar la implementación 
de operaciones como: ``Listar los reviews más populares de determinada fecha'' o ``Hacer un promedio de puntaje para un ítem determinado''
\\
Estrategia: Exactamente el mismo principio que para corregir los formatos de las fechas, sólo que un poco más simple porque sólo se realizará 
para una propiedad en lugar de 4.
\\
Primero se realizó una consulta SPARQL buscando los valores de ratings que no estén dentro de los correctos. \\

 \begin{lstlisting}[frame=single]
 SELECT distinct ?value (count (distinct ?review) as ?cantidad)
 WHERE{ 
 ?review <http://local.org/id> ?id .
 ?review <http://purl.org/stuff/rev#rating> ?value .
 FILTER NOT EXISTS{
 ?review <http://local.org/duplicateOf> ?dup .
 }
 FILTER (!REGEX(str(?value), "^[0-9]{1}$", "i")) .
 FILTER (!REGEX(str(?value), "^[0-9]{2}$", "i")) .
 FILTER (!REGEX(str(?value), "^[0-9]{3}$", "i")) .
 }GROUP BY ?value ORDER BY DESC(?cantidad)
 \end{lstlisting}
 Y luego analizando los resultados se fueron agregando los siguientes filtros a la consulta:\\
 \begin{lstlisting}[frame=single]
 FILTER (!REGEX(str(?value), "^[0-9]{1}½$", "i")) . 
 FILTER (!REGEX(str(?value), "^[0-9]{2}\\.[0-9]{1}$", "i")) .
 FILTER (!REGEX(str(?value), "^[0-9]{1}\\.[0-9]{1}$", "i")) . 
 FILTER (!REGEX(str(?value), "^[0-9]{1},[0-9]{1}$", "i")) .
 FILTER (!REGEX(str(?value), "^[0-9]{1} ", "i")) .  
 FILTER (!REGEX(str(?value), "^Rating [0-9]{1}", "i")) .  
 FILTER (!REGEX(str(?value), "^About.com Rating  [0-9]{1}", "i")) . 
 FILTER (!REGEX(str(?value), "^[0-9]{1}\\.[0-9]{1} ", "i")) .  
 FILTER (!REGEX(str(?value), "Rating [0-9]{1}", "i")) .
 FILTER (!REGEX(str(?value), "\\([0-9]{1} ", "i")) .
 \end{lstlisting}
 Una vez que los resultados arrojados por la consulta fueron 0. Se realizó el algoritmo que lleve el rating al formato correspondiente 
 según su expresión regular.\\
 \\
 Resultados:\\
 \begin{tabular}{| l | c |}
 Expresión regular & Cantidad de ratings \\
 \verb|^[0-9]{1}½$| & 3722\\
 \verb|^[0-9]{2}\\.[0-9]{1}$| & 250\\
 \verb|^[0-9]{1}\\.[0-9]{1}$| & 63695\\
 \verb|^[0-9]{1},[0-9]{1}$| & 45927\\
 \verb|^[0-9]{1} | & 26314\\
 \verb|^Rating [0-9]{1}| & 149\\
 \verb|^About.com Rating  [0-9]{1}| & 2613\\
 \verb|^[0-9]{1}\\.[0-9]{1} | & 5603\\
 \verb|Rating [0-9]{1}| & 3300\\
 \verb|\\([0-9]{1} | & 4176 
 \end{tabular}